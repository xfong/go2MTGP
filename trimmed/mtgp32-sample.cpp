/**
 * Sample host program for OpenCL
 * using 1 parameter for 1 generator
 */
#define CL_USE_DEPRECATED_OPENCL_1_2_APIS
#define CL_USE_DEPRECATED_OPENCL_2_0_APIS
#define __CL_ENABLE_EXCEPTIONS

#include "opencl_tools.hpp"

#include <cstddef>
#include <iostream>
#include <iomanip>
#include <sstream>
#include <string>
#include <float.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>

typedef uint32_t uint;
#include "mtgp32-sample-common.h"
#include "parse_opt.h"

using namespace std;
using namespace cl;

/* ================== */
/* OpenCL information */
/* ================== */
std::vector<cl::Platform> platforms;
std::vector<cl::Device> devices;
cl::Context context;
std::string programBuffer;
cl::Program program;
cl::Program::Sources source;
cl::CommandQueue queue;
std::string errorMessage;

/* =========================
   declaration
   ========================= */

/* Begin import from mtgp32-fast.h */
/**
 * \struct MTGP32_PARAMS_FAST_T
 * MTGP32 parameters.
 * Some element is redundant to keep structure simple.
 *
 * \b pos is a pick up position which is selected to have good
 * performance on graphic processors.  3 < \b pos < Q, where Q is a
 * maximum number such that the size of status array - Q is a power of
 * 2.  For example, when \b mexp is 44497, size of 32-bit status array
 * is 696, and Q is 184, then \b pos is between 4 and 183. This means
 * 512 parallel calculations is allowed when \b mexp is 44497.
 *
 * \b poly_sha1 is SHA1 digest of the characteristic polynomial of
 * state transition function. SHA1 is calculated based on printing
 * form of the polynomial. This is important when we use parameters
 * generated by the dynamic creator which
 *
 * \b mask This is a mask to make the dimension of state space have
 * just Mersenne Prime. This is redundant.
 */
typedef struct MTGP32_PARAMS_FAST_T {
    int mexp;			/**< Mersenne exponent. This is redundant. */
    int pos;			/**< pick up position. */
    int sh1;			/**< shift value 1. 0 < sh1 < 32. */
    int sh2;			/**< shift value 2. 0 < sh2 < 32. */
    uint32_t tbl[16];		/**< a small matrix. */
    uint32_t tmp_tbl[16];	/**< a small matrix for tempering. */
    uint32_t flt_tmp_tbl[16];	/**< a small matrix for tempering and
				 converting to float. */
    uint32_t mask;		/**< This is a mask for state space */
    unsigned char poly_sha1[21]; /**< SHA1 digest */
} mtgp32_params_fast_t;

/**
 * \struct MTGP32_STATUS_FAST_T
 * MTGP32 internal state array.
 * In this structure, we use \b larger_size and \b larger_mask to
 * avoid slow operation of remainder (%).
 *
 * \b size is the minimum needed size to represent linear space of
 * two element filed as 32-bit array.
 *
 * \b large_size is a minimum power of 2 which is larger than \b size.
 * \b array has this size.
 *
 * \b large_mask is a bit mask to update \b idx in a fast way.
 * \b idx is updated by `logical and' \b & with large_mask.
 */
typedef struct MTGP32_STATUS_FAST_T {
    int idx;			/**< index */
    int size;			/**< minimum needed size */
    int large_size;		/**< real size of array */
    int large_mask;		/**< bit mask to update \b idx */
    uint32_t array[];		/**< internal state array */
} mtgp32_status_fast_t;

/**
 * \struct MTGP32_STATUS_FAST_T
 * MTGP32 interface structure
 */
typedef struct MTGP32_FAST_T {
    mtgp32_params_fast_t params; /**< parameters */
    mtgp32_status_fast_t *status; /**< internal state */
} mtgp32_fast_t;

/**
 * parameter constants tables for MEXP=11213.
 * \b size - \b pos > 256.
 */
extern mtgp32_params_fast_t mtgp32_params_fast_11213[128];
/**
 * parameter constants tables for MEXP=23209.
 * \b size - \b pos > 512.
 */
extern mtgp32_params_fast_t mtgp32_params_fast_23209[128];
/**
 * parameter constants tables for MEXP=44497.
 * \b size - \b pos > 1024.
 */
extern mtgp32_params_fast_t mtgp32_params_fast_44497[128];

int mtgp32_init(mtgp32_fast_t *mtgp32,
		const mtgp32_params_fast_t *para, uint32_t seed);

void mtgp32_init_state(uint32_t array[],
      const mtgp32_params_fast_t *para, uint32_t seed);

void mtgp32_free(mtgp32_fast_t *mtgp32);
inline static void mtgp32_do_recursion(uint32_t *r, uint32_t x1,
				       uint32_t x2, uint32_t y,
				       int sh1, int sh2,
				       uint32_t mask, uint32_t tbl[16]);
inline static void mtgp32_next_state(mtgp32_fast_t *mtgp32);
inline static float mtgp32_genrand_close1_open2(mtgp32_fast_t *mtgp32);
inline static float mtgp32_genrand_close_open(mtgp32_fast_t *mtgp32);

/* End import from mtgp32-fast.h */

static mtgp32_fast_t * mtgp32;
static bool thread_max = false;
struct buffers_t {
    Buffer status;
    Buffer rec;
    Buffer tmp;
    Buffer flt;
    Buffer pos;
    Buffer sh1;
    Buffer sh2;
};

static int init_check_data(mtgp32_fast_t mtgp32[],
			   int group_num,
			   uint32_t seed);
static void free_check_data(mtgp32_fast_t mtgp32[], int group_num);
static void check_data(uint32_t * h_data,
		       int num_data,
		       int group_num);
static void check_data01(float * h_data,
			 int num_data,
			 int group_num);
static void check_status(uint * h_status,
			 int group_num);
static void initialize_by_seed(options& opt,
			       buffers_t mtgp_buffers,
			       int group,
			       uint32_t seed);
static Buffer get_rec_buff(mtgp32_params_fast_t * params,
			   int group_num);
static Buffer get_tmp_buff(mtgp32_params_fast_t * params,
			   int group_num);
static Buffer get_flt_tmp_buff(mtgp32_params_fast_t * params,
			       int group_num);
static Buffer get_pos_buff(mtgp32_params_fast_t * params,
			   int group_num);
static Buffer get_sh1_buff(mtgp32_params_fast_t * params,
			   int group_num);
static Buffer get_sh2_buff(mtgp32_params_fast_t * params,
			   int group_num);
static void initialize_by_seed(buffers_t mtgp_buffers,
			       int group,
			       uint32_t seed);
static void generate_single01(buffers_t& mtgp_buffers,
			      int group_num,
			      int data_size);
static int test(int argc, char * argv[]);
/* From mtgp32-fast.c */
static int alloc_state(mtgp32_fast_t *mtgp32, const mtgp32_params_fast_t *para);
static const uint32_t non_zero = 0x4d544750;


/* ========================= */
/* mtgp32 sample code        */
/* ========================= */
/**
 * main
 * catch errors
 *@param argc number of arguments
 *@param argv array of arguments
 *@return 0 normal, -1 error
 */
int main(int argc, char * argv[])
{
    try {
	return test(argc, argv);
    } catch (Error e) {
	cerr << "Error Code:" << e.err() << endl;
	cerr << e.what() << endl;
    }
}

/**
 * sample main
 *@param argc number of arguments
 *@param argv array of arguments
 *@return 0 normal, -1 error
 */
static int test(int argc, char * argv[])
{
#if defined(DEBUG)
    cout << "test start" << endl;
#endif
    options opt;
    if (!parse_opt(opt, argc, argv)) {
	return -1;
    }
    // OpenCL setup
#if defined(DEBUG)
    cout << "openCL setup start" << endl;
#endif
    platforms = getPlatforms();
    devices = getDevices();
    context = getContext();
    source = getSource("mtgp32.cl");
    program = getProgram();
    queue = getCommandQueue();
#if defined(DEBUG)
    cout << "openCL setup end" << endl;
#endif

    int max_group_size = getMaxGroupSize();
    if (opt.group_num > max_group_size) {
	cout << "group_num greater than max value("
	     << max_group_size << ")"
	     << endl;
	return -1;
    }
    int max_size = getMaxWorkItemSize(0);
    if (MTGP32_TN > max_size) {
	cout << "workitem size is greater than max value("
	     << dec << max_size << ")"
	     << "current:" << dec << MTGP32_N << endl;
	return -1;
    }
    if (MTGP32_N > max_size) {
	thread_max = true;
    }
    int local_mem_size = getLocalMemSize();
    if (local_mem_size < sizeof(uint32_t) * MTGP32_N * 2) {
	cout << "local memory size not sufficient:"
	     << dec << local_mem_size << endl;
	return -1;
    }
    Buffer status_buffer(context,
			 CL_MEM_READ_WRITE,
			 sizeof(uint32_t) * MTGP32_N * opt.group_num);
    buffers_t mtgp_buffers;
    mtgp_buffers.status = status_buffer;
    mtgp_buffers.rec = get_rec_buff(mtgp32_params_fast_11213, opt.group_num);
    mtgp_buffers.tmp = get_tmp_buff(mtgp32_params_fast_11213, opt.group_num);
    mtgp_buffers.flt = get_flt_tmp_buff(mtgp32_params_fast_11213,
					opt.group_num);
    mtgp_buffers.pos = get_pos_buff(mtgp32_params_fast_11213, opt.group_num);
    mtgp_buffers.sh1 = get_sh1_buff(mtgp32_params_fast_11213, opt.group_num);
    mtgp_buffers.sh2 = get_sh2_buff(mtgp32_params_fast_11213, opt.group_num);
    // initialize by seed
    // generate uint32_t
    mtgp32 = new mtgp32_fast_t[opt.group_num];
    init_check_data(mtgp32, opt.group_num, 1234);
    initialize_by_seed(mtgp_buffers, opt.group_num, 1234);
	generate_single01(mtgp_buffers, opt.group_num, opt.data_count);
    free_check_data(mtgp32, opt.group_num);
    delete[] mtgp32;
    return 0;
}

/**
 * initialize mtgp status in device global memory
 * using 1 parameter for 1 generator.
 *@param mtgp_buffers device global memories
 *@param group number of group
 *@param seed seed for initialization
 */
static void initialize_by_seed(buffers_t mtgp_buffers,
			       int group,
			       uint32_t seed)
{
#if defined(DEBUG)
    cout << "initialize_by_seed start" << endl;
#endif
    Kernel init_kernel(program, "mtgp32_init_seed_kernel");
    init_kernel.setArg(0, mtgp_buffers.rec);
    init_kernel.setArg(1, mtgp_buffers.tmp);
    init_kernel.setArg(2, mtgp_buffers.flt);
    init_kernel.setArg(3, mtgp_buffers.pos);
    init_kernel.setArg(4, mtgp_buffers.sh1);
    init_kernel.setArg(5, mtgp_buffers.sh2);
    init_kernel.setArg(6, mtgp_buffers.status);
    init_kernel.setArg(7, seed);
    int local_item = MTGP32_N;
    if (thread_max) {
	local_item = MTGP32_TN;
    }
    NDRange global(group * local_item);
    NDRange local(local_item);
    Event event;
#if defined(DEBUG)
    cout << "global:" << dec << group * local_item << endl;
    cout << "group:" << dec << group << endl;
    cout << "local:" << dec << local_item << endl;
#endif
    queue.enqueueNDRangeKernel(init_kernel,
			       NullRange,
			       global,
			       local,
			       NULL,
			       &event);
    double time = get_time(event);
    uint status[group * MTGP32_N];
    queue.enqueueReadBuffer(mtgp_buffers.status,
			    CL_TRUE,
			    0,
			    sizeof(uint32_t) * MTGP32_N * group,
			    status);
    cout << "initializing time = " << time * 1000 << "ms" << endl;
#if defined(DEBUG)
    cout << "status[0]:" << hex << status[0] << endl;
    cout << "status[MTGP32_N - 1]:" << hex << status[MTGP32_N - 1] << endl;
    cout << "status[MTGP32_N]:" << hex << status[MTGP32_N] << endl;
    cout << "status[MTGP32_N + 1]:" << hex << status[MTGP32_N + 1] << endl;
#endif
    check_status(status, group);
#if defined(DEBUG)
    cout << "initialize_by_seed end" << endl;
#endif
}

/**
 * generate single precision floating point numbers in the range [0, 1)
 * in device global memory
 *@param mtgp_buffers device global memories
 *@param group_num number of groups for execution
 *@param data_size number of data to generate
 */
static void generate_single01(buffers_t& mtgp_buffers,
			      int group_num,
			      int data_size)
{
    int item_num = MTGP32_TN * group_num;
    int min_size = MTGP32_LS * group_num;
    if (data_size % min_size != 0) {
	data_size = (data_size / min_size + 1) * min_size;
    }
    Kernel single_kernel(program, "mtgp32_single01_kernel");
    Buffer output_buffer(context,
			 CL_MEM_READ_WRITE,
			 data_size * sizeof(float));
    single_kernel.setArg(0, mtgp_buffers.rec);
    single_kernel.setArg(1, mtgp_buffers.tmp);
    single_kernel.setArg(2, mtgp_buffers.flt);
    single_kernel.setArg(3, mtgp_buffers.pos);
    single_kernel.setArg(4, mtgp_buffers.sh1);
    single_kernel.setArg(5, mtgp_buffers.sh2);
    single_kernel.setArg(6, mtgp_buffers.status);
    single_kernel.setArg(7, output_buffer);
    single_kernel.setArg(8, data_size / group_num);
    NDRange global(item_num);
    NDRange local(MTGP32_TN);
    Event generate_event;
    queue.enqueueNDRangeKernel(single_kernel,
			       NullRange,
			       global,
			       local,
			       NULL,
			       &generate_event);
    float * output = new float[data_size];
    generate_event.wait();
    queue.enqueueReadBuffer(output_buffer,
			    CL_TRUE,
			    0,
			    data_size * sizeof(float),
			    &output[0]);
    check_data01(output, data_size, group_num);
    print_float(&output[0], data_size, item_num);
    double time = get_time(generate_event);
    delete[] output;
    cout << "generate time:" << time * 1000 << "ms" << endl;
}


/* ==============
 * check programs
 * ==============*/
static int init_check_data(mtgp32_fast_t mtgp32[],
			   int group_num,
			   uint32_t seed)
{
#if defined(DEBUG)
    cout << "init_check_data start" << endl;
#endif
    for (int i = 0; i < group_num; i++) {
	int rc = mtgp32_init(&mtgp32[i],
			     &mtgp32_params_fast_11213[i],
			     seed + i);
	if (rc) {
	    return rc;
	}
    }
#if defined(DEBUG)
    cout << "init_check_data end" << endl;
#endif
    return 0;
}

static void free_check_data(mtgp32_fast_t mtgp32[], int group_num)
{
#if defined(DEBUG)
    cout << "free_check_data start" << endl;
#endif
    for (int i = 0; i < group_num; i++) {
	mtgp32_free(&mtgp32[i]);
    }
#if defined(DEBUG)
    cout << "free_check_data end" << endl;
#endif
}

static void check_data01(float * h_data,
			 int num_data,
			 int group_num)
{
#if defined(DEBUG)
    cout << "check_data start" << endl;
#endif
    int size = num_data / group_num;
#if defined(DEBUG)
    cout << "size = " << dec << size << endl;
#endif
    bool error = false;
    for (int i = 0; i < group_num; i++) {
	bool disp_flg = true;
	int count = 0;
	for (int j = 0; j < size; j++) {
	    float r = mtgp32_genrand_close_open(&mtgp32[i]);
	    float d = h_data[i * size + j];
	    bool ok = (-FLT_EPSILON <= (r - d))
		&& ((r - d) <= FLT_EPSILON);
	    if (!ok && disp_flg) {
		cout << "mismatch i = " << dec << i
		     << " j = " << dec << j
		     << " data = " << hex << h_data[i * size + j]
		     << " r = " << hex << r << endl;
		cout << "check_data check N.G!" << endl;
		count++;
		error = true;
	    }
	    if (count > 10) {
		disp_flg = false;
	    }
	}
    }
    if (!error) {
	cout << "check_data check O.K!" << endl;
    } else {
	throw cl::Error(-1, "mtgp32 check_data error!");
    }
#if defined(DEBUG)
    cout << "check_data end" << endl;
#endif
}

static void check_status(uint * h_status,
			 int group_num)
{
#if defined(DEBUG)
    cout << "check_status start" << endl;
#endif
    int counter = 0;
    int large_size = mtgp32[0].status->large_size;
    for (int i = 0; i < group_num; i++) {
	for (int j = 0; j < MTGP32_N; j++) {
	    int idx = mtgp32[i].status->idx - MTGP32_N + 1 + large_size;
	    uint32_t x = h_status[i * MTGP32_N + j];
	    uint32_t r = mtgp32[i].status->array[(j + idx) % large_size];
	    if (j == 0) {
		x = x & mtgp32[i].params.mask;
		r = r & mtgp32[i].params.mask;
	    }
#if defined(DEBUG)
	    if (i == 0 && counter == 0) {
		cout << "i = " << dec << i
		     << " j = " << dec << j
		     << " device = " << hex << x
		     << " host = " << hex << r << endl;
	    }
#endif
	    if (x != r) {
		cout << "mismatch i = " << dec << i
		     << " j = " << dec << j
		     << " device = " << hex << x
		     << " host = " << hex << r << endl;
		cout << "check_status check N.G!" << endl;
		counter++;
	    }
	    if (counter > 10) {
		return;
	    }
	}
    }
    if (counter == 0) {
	cout << "check_status check O.K!" << endl;
    } else {
	throw cl::Error(-1, "mtgp32 check_status error!");
    }
#if defined(DEBUG)
    cout << "check_status end" << endl;
#endif
}

/* ==============
 * utility programs
 * ==============*/
static Buffer get_rec_buff(mtgp32_params_fast_t * params,
			   int group_num)
{
#if defined(DEBUG)
    cout << "get_rec_buff start" << endl;
#endif
    // recursion table
    uint32_t * rec_tbl = new uint32_t[MTGP32_TS * group_num];
    for (int i = 0; i < group_num; i++) {
	for (int j = 0; j < MTGP32_TS; j++) {
	    rec_tbl[i * MTGP32_TS + j] = params[i].tbl[j];
	}
    }
    Buffer recursion_buffer(context,
			    CL_MEM_READ_ONLY,
			    MTGP32_TS * group_num * sizeof(uint32_t));
    queue.enqueueWriteBuffer(recursion_buffer,
			     CL_TRUE,
			     0,
			     MTGP32_TS * group_num * sizeof(uint32_t),
			     rec_tbl);
    delete[] rec_tbl;
#if defined(DEBUG)
    cout << "get_rec_buff end" << endl;
#endif
    return recursion_buffer;
}

static Buffer get_tmp_buff(mtgp32_params_fast_t * params,
			   int group_num) {
#if defined(DEBUG)
    cout << "get_tmp_buff start" << endl;
#endif
    // temper table
    uint32_t * tmp_tbl = new uint32_t[MTGP32_TS * group_num];
    for (int i = 0; i < group_num; i++) {
	for (int j = 0; j < MTGP32_TS; j++) {
	    tmp_tbl[i * MTGP32_TS + j] = params[i].tmp_tbl[j];
	}
    }
    Buffer temper_buffer(context,
			 CL_MEM_READ_ONLY,
			 MTGP32_TS * group_num * sizeof(uint32_t));
    queue.enqueueWriteBuffer(temper_buffer,
			     CL_TRUE,
			     0,
			     MTGP32_TS * group_num * sizeof(uint32_t),
			     tmp_tbl);
    delete[] tmp_tbl;
#if defined(DEBUG)
    cout << "get_tmp_buff end" << endl;
#endif
    return temper_buffer;
}

static Buffer get_flt_tmp_buff(mtgp32_params_fast_t * params,
			       int group_num) {
#if defined(DEBUG)
    cout << "get_flt_tmp_buff start" << endl;
#endif
    // temper table
    uint32_t * tmp_tbl = new uint32_t[MTGP32_TS * group_num];
    for (int i = 0; i < group_num; i++) {
	for (int j = 0; j < MTGP32_TS; j++) {
	    tmp_tbl[i * MTGP32_TS + j] = params[i].flt_tmp_tbl[j];
	}
    }
    Buffer temper_buffer(context,
			 CL_MEM_READ_ONLY,
			 MTGP32_TS * group_num * sizeof(uint32_t));
    queue.enqueueWriteBuffer(temper_buffer,
			     CL_TRUE,
			     0,
			     MTGP32_TS * group_num * sizeof(uint32_t),
			     tmp_tbl);
    delete[] tmp_tbl;
#if defined(DEBUG)
    cout << "get_flt_tmp_buff end" << endl;
#endif
    return temper_buffer;
}

static Buffer get_pos_buff(mtgp32_params_fast_t * params,
			   int group_num) {
#if defined(DEBUG)
    cout << "get_pos_buff start" << endl;
#endif
    // temper table
    uint32_t * pos_tbl = new uint32_t[group_num];
    for (int i = 0; i < group_num; i++) {
	pos_tbl[i] = params[i].pos;
    }
    Buffer pos_buffer(context,
		      CL_MEM_READ_ONLY,
		      group_num * sizeof(uint32_t));
    queue.enqueueWriteBuffer(pos_buffer,
			     CL_TRUE,
			     0,
			     group_num * sizeof(uint32_t),
			     pos_tbl);
    delete[] pos_tbl;
#if defined(DEBUG)
    cout << "get_pos_buff end" << endl;
#endif
    return pos_buffer;
}

static Buffer get_sh1_buff(mtgp32_params_fast_t * params,
			   int group_num) {
#if defined(DEBUG)
    cout << "get_sh1_buff start" << endl;
#endif
    // temper table
    uint32_t * sh1_tbl = new uint32_t[group_num];
    for (int i = 0; i < group_num; i++) {
	sh1_tbl[i] = params[i].sh1;
    }
    Buffer sh1_buffer(context,
		      CL_MEM_READ_ONLY,
		      group_num * sizeof(uint32_t));
    queue.enqueueWriteBuffer(sh1_buffer,
			     CL_TRUE,
			     0,
			     group_num * sizeof(uint32_t),
			     sh1_tbl);
    delete[] sh1_tbl;
#if defined(DEBUG)
    cout << "get_sh1_buff end" << endl;
#endif
    return sh1_buffer;
}

static Buffer get_sh2_buff(mtgp32_params_fast_t * params,
			   int group_num) {
#if defined(DEBUG)
    cout << "get_sh2_buff start" << endl;
#endif
    // temper table
    uint32_t * sh2_tbl = new uint32_t[group_num];
    for (int i = 0; i < group_num; i++) {
	sh2_tbl[i] = params[i].sh2;
    }
    Buffer sh2_buffer(context,
		      CL_MEM_READ_ONLY,
		      group_num * sizeof(uint32_t));
    queue.enqueueWriteBuffer(sh2_buffer,
			     CL_TRUE,
			     0,
			     group_num * sizeof(uint32_t),
			     sh2_tbl);
    delete[] sh2_tbl;
#if defined(DEBUG)
    cout << "get_sh2_buff end" << endl;
#endif
    return sh2_buffer;
}

/* From mtgp32-fast.c */
/**
 * \private
 * This function allocates the internal state vector.
 *
 * @param[in,out] mtgp32 MTGP all in one structure.
 * @param[in] para a parameter structure.
 * @return allocation status. if 0 O.K.
 */
static int alloc_state(mtgp32_fast_t *mtgp32,
		       const mtgp32_params_fast_t *para) {
    int size = para->mexp / 32 + 1;
    int large_size;
    mtgp32_status_fast_t *st;

    int x;
    int y = size;
    for (x = 1; (x != size) && (y > 0); x <<= 1, y >>= 1);
    large_size = x;

    st = (mtgp32_status_fast_t *)malloc(sizeof(mtgp32_status_fast_t)
				     + sizeof(uint32_t) * large_size);
    if (st == NULL) {
	return -1;
    }
    mtgp32->params = *para;
    mtgp32->status = st;
    st->size = size;
    st->large_size = large_size;
    st->large_mask = large_size -1;
    return 0;
}

/**
 * \public
 * This function allocates and initializes the internal state array
 * with a 32-bit integer seed. The allocated memory should be freed by
 * calling mtgp32_free(). \b para should be one of the elements in
 * the parameter table (mtgp32-param-ref.c).
 *
 * @param[out] mtgp32 MTGP structure.
 * @param[in] para parameter structure
 * @param[in] seed a 32-bit integer used as the seed.
 * @return memory allocation result. if 0 O.K.
 */
int mtgp32_init(mtgp32_fast_t *mtgp32,
		const mtgp32_params_fast_t *para, uint32_t seed) {
    int rc;
    rc = alloc_state(mtgp32, para);
    if (rc) {
	return rc;
    }
    mtgp32->status->idx = mtgp32->status->size - 1;
    mtgp32_init_state(mtgp32->status->array, para, seed);
    return 0;
}

/**
 * This function initializes the internal state array with a 32-bit
 * integer seed. The allocated memory should be freed by calling
 * mtgp32_free(). \b para should be one of the elements in the
 * parameter table (mtgp32-param-ref.c).
 *
 * This function is call by cuda program, because cuda program uses
 * another structure and another allocation method.
 *
 * @param[out] array MTGP internal status vector.
 * @param[in] para parameter structure
 * @param[in] seed a 32-bit integer used as the seed.
 */
void mtgp32_init_state(uint32_t array[],
		      const mtgp32_params_fast_t *para, uint32_t seed) {
    int i;
    int size = para->mexp / 32 + 1;
    uint32_t hidden_seed;
    uint32_t tmp;
    hidden_seed = para->tbl[4] ^ (para->tbl[8] << 16);
    tmp = hidden_seed;
    tmp += tmp >> 16;
    tmp += tmp >> 8;
    memset(array, tmp & 0xff, sizeof(uint32_t) * size);
    array[0] = seed;
    array[1] = hidden_seed;
    for (i = 1; i < size; i++) {
	array[i] ^= UINT32_C(1812433253) * (array[i - 1]
					    ^ (array[i - 1] >> 30))
	    + i;
    }
}

/**
 * This releases the memory allocated by mtgp32_init(), mtgp32_init_by_array(),
 * mtgp32_init_by_str().
 *
 * @param[in,out] mtgp32 MTGP all in one structure.
 */
void mtgp32_free(mtgp32_fast_t *mtgp32) {
    free(mtgp32->status);
}

/**
 * This is a recursion formula of the generator.
 * MTGP32 is a 32-bit generator, but using 32-bit operations to fit to
 * graphic processors.

 * @param[out] r output
 * @param[in] x1 the farthest part of state array.
 * @param[in] x2 the second farthest part of state array.
 * @param[in] y a part of state array.
 * @param[in] sh1 the shift parameter 1.
 * @param[in] sh2 the shift parameter 2.
 * @param[in] mask the bit mask parameter.
 * @param[in] tbl the matrix parameter.
 */
inline static void mtgp32_do_recursion(uint32_t *r, uint32_t x1,
				       uint32_t x2, uint32_t y,
				       int sh1, int sh2,
				       uint32_t mask, uint32_t tbl[16]) {
    uint32_t x;

    x = (x1 & mask) ^ x2;
    x ^= x << sh1;
    y = x ^ (y >> sh2);
    *r = y ^ tbl[y & 0x0f];
}

/**
 * The state transition function.
 * @param[in,out] mtgp32 the all in one structure
 */
inline static void mtgp32_next_state(mtgp32_fast_t *mtgp32) {
    uint32_t *array = mtgp32->status->array;
    int idx;
    int pos = mtgp32->params.pos;
    int large_size = mtgp32->status->large_size;
    uint32_t large_mask = mtgp32->status->large_mask;
    int size = mtgp32->status->size;

    mtgp32->status->idx = (mtgp32->status->idx + 1) & large_mask;
    idx = mtgp32->status->idx;
    mtgp32_do_recursion(&(array[idx]),
			array[(idx - size + large_size) & large_mask],
			array[(idx - size + large_size + 1) & large_mask],
			array[(idx + pos - size + large_size) & large_mask],
			mtgp32->params.sh1,
			mtgp32->params.sh2,
			mtgp32->params.mask,
			mtgp32->params.tbl);
}

/**
 * The tempering and converting function.
 * @param[in] flt_tmp_tbl the pre-computed tempering table.
 * @param[in] r the value to be tempered.
 * @param[in] t the tempering helper value.
 * @return the tempered value.
 */
inline static float mtgp32_temper_float(const uint32_t flt_tmp_tbl[16],
					  uint32_t r, uint32_t t) {
    union {
	uint32_t u;
	float f;
    } x;
    t ^= t >> 16;
    t ^= t >> 8;
    r = r >> 9;
    x.u = r ^ flt_tmp_tbl[t & 0x0f];
    return x.f;
}

/**
 * This function generates and returns single precision pseudorandom
 * number which distributes uniformly in the range [1, 2).
 * mtgp32_init(), mtgp32_init_by_array() or mtgp32_init_by_str() must
 * be called before this function.
 *
 * @param[in,out] mtgp32 MTGP all in one structure.
 * @return single precision floating point pseudorandom number
 */
inline static float mtgp32_genrand_close1_open2(mtgp32_fast_t *mtgp32) {
    int idx;
    uint32_t *flt_tmp_tbl = mtgp32->params.flt_tmp_tbl;
    uint32_t *array = mtgp32->status->array;
    int pos = mtgp32->params.pos;
    int large_size = mtgp32->status->large_size;
    int size = mtgp32->status->size;
    uint32_t large_mask = mtgp32->status->large_mask;

    mtgp32_next_state(mtgp32);
    idx = mtgp32->status->idx;
    return mtgp32_temper_float(flt_tmp_tbl,
				array[idx],
				array[(idx + pos - 1 - size + large_size)
				      & large_mask]);
}

/**
 * This function generates and returns single precision pseudorandom
 * number which distributes uniformly in the range [0, 1).
 * mtgp32_init(), mtgp32_init_by_array() or mtgp32_init_by_str() must
 * be called before this function.
 *
 * @param[in,out] mtgp32 MTGP all in one structure.
 * @return single precision floating point pseudorandom number
 */
inline static float mtgp32_genrand_close_open(mtgp32_fast_t *mtgp32) {
    return mtgp32_genrand_close1_open2(mtgp32) - 1.0F;
}

